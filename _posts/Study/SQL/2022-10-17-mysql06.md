---
title:  "Chap 6. SQL 데이터 추가, 삭제, 갱신" 
excerpt: "내가 널 인지한 순간 넌 ,, 글자에서 정보가 됐어!"

categories:
  - SQL
tags:
  - [Database, SQL]

toc: true
toc_sticky: true
 
date: 2022-10-17
last_modified_at: 2022-10-17

---

지금까지 배운 SELECT 명령은 데이터를 검색하는 것으로 서버가 클라이언트에게 결과를 반환하는 형식이었다. 오늘 게시물에서는 클라이언트가 서버에 데이터를 전송, 삭제, 갱신(수정) 명령을 전송하여 테이블 속 데이터를 변화하는 작업을 작성한다. 

### INSERT 데이터 추가

INSERT 명령은 테이블의 행 단위로 데이터를 추가한다. 

*테이블의 데이터를 변경(추가, 삭제, 갱신)하기 전 테이블을 확인해보는 것이 좋다. DESC구 사용*

```sql
INSERT INTO 테이블명 VALUES (값1, 값2, 값3 ...)
```

값을 지정할 땐 테이블 속 해당 열의 개수와 데이터 형식에 맞도록 지정해야한다. 가령 문자열 형식이면 문자열, 최대 길이, 제어 형식에 맞게 작성하도록 한다. 

#### 값을 저장할 열 지정

```sql
INSERT INTO 테이블명 (열1, 열2, ...) VALUES (값1, 값2, ...)
```

이 문법을 적용하면 지정한 열에 값을 넣어 행을 추가할 수 있다. 열의 개수만큼 값을 입력해야한다. 
만일 테이블 정의에 의해 열의 개수가 3개인데 지정한 열과 값이 2개라면 나머지 하나는 기본값으로 자동으로 저장된다. 

#### NOT NULL 제약 

행을 추가할 때 유효한 값이 없는 상태(NULL)로 두고 싶은 경우 값에 NULL을 입력하면 된다. 
하지만 만약 해당 열에 **NOT NULL 제약**이 걸려있다면 NULL 값을 입력할 수 없다. 
이처럼 데이터를 설정으로 제한하는것을 **제약**이라고 한다. 

NOT NULL 제약을 하는 이유는 보통 NULL 값은 데이터 처리에 방해가 될 때 혹은 어떤 값이든 입력이 되어야 할 때 사용되는 제약이다. 

#### DEFAULT 기본값

DESC 명령으로 열 구성 (간략한 스키마)를 살펴보면 DEFAULT라는 항목이 있다. 이는 `기본값`으로 값을 지정하지 않았을 때 자동으로 저장되는 값을 말한다. 간단한 개념이다. 

```sql
INSERT INTO 테이블명 (열1, 열2) VALUES (값1, DEFAULT)
```

위와 같은 명령문을 입력했을 때 열2의 값은 초기 테이블 정의 속 기본값이 입력이된다. 이를 명시적으로 기본값을 지정한다고 하는데 ,, 사실 큰 쓸모는 없는 것 같다. 

이유는 앞서 열 개수보다 값을 적게 입력하면 나머지 지정하지 않은 값에는 기본값이 자동으로 저장된다는 것이다. 즉, DEFAULT를 입력하지 않아도 암묵적으로 이것이 생략된것이라고 보면 된다. 

### DELETE 삭제 

```sql
DELETE FROM 테이블명 WHERE 조건식
```

데이터베이스는 저장장치에 데이터를 저장해 관리한다. 당연히 저장장치에는 용량이 정해져있어 무지성으로 데이터를 저장할 수 없다. 결국 저장장치가 가득차면 삭제, 정리를 통해 데이터를 관리해야한다는 것이다. 

위 DELETE 명령문을 입력하면 해당 테이블에서 조건이 맞는 행이 삭제된다. 이때 WHERE 구를 작성하지 않는다면 모든 행을 지정하는 것이 되어 테이블의 모든 데이터가 삭제된다. 

⭐️ 정말 정말 주의할 것. 

DELETE 명령문은 실행 시 재확인을 위한 대화창이 표시되지 않는다. 또한, 되돌기도 되지 않기에 각별히 주의하여 조건식을 채워야한다. 데이터 날려버리면 복구는 ,,, 매우 어렵다는 것을 상기하자.

### UPDATE 갱신(수정)

데이터 갱신 작업은 데이터를 잘못입력하거나 수정이 필요할 때 사용한다. 

```sql
UPDATE 테이블명 SET 열1 = 값1, 열2 = 값2 ... WHERE 조건식
```

DELETE와 달리 UPDATE는 셀 단위로 데이터를 갱신할 수 있다. 

WHERE 구를 통해 갱신하려는 행을 지정하고 SET 구에서 열을 지정 후 값을 입력한다. SET 구에 입력한 갱신값은 WHERE 구 조건에 맞는 모든 행에 모두 입력이 된다. 즉, WHERE 구를 생략하면 SET 구의 해당 열이 모두 같은 값으로 갱신된다. 

여기서 `=`은 비교 연산자가 아닌 값을 대입하는 대입 연산자이다. 또한, 테이블에 없는 열을 지정하면 오류가 난다. 갱신하고자하는 값은 해당 열의 데이터 형식, 제약 조건에 맞게 입력해야한다. 

#### UPDATE 구문 주의사항

UPDATE 구는 INSERT 구와 달리 기존의 존재 했던 행이 변화하는 것이 특징이다. 즉, 갱신 이전의 값과 갱신 이후의 값 두 가지 상태로 나눌 수 있다. 

```sql
UPDATE 테이블명 SET 순번 = 순번 + 1 
```

위와 같이 모든 행의 순번에 1씩 더하는 구문을 실행하면 어떻게 될까? 결과는 본래 값(갱신 전의 값)에서 1씩 더한 값이 나온다는 것이다. 우리가 늘 프로그래밍을 할 때 **좌항**은 **연산 후의 값**, **우항**은 **연산 전의 값**으로 처리할 식으로 생각하듯 같은 형식을 취하면 된다. 비교 연산자가 아니기에 갱신 대상의 열이 들어가도 상관이 없다. 

#### 복수열 갱신

앞에 UPDATE 구문식에 썼듯 SET 구에 갱신하려는 열의 값을 콤마(,)로 나누어 복수 지정해도 된다. 오히려 갱신을 두 구문으로 나누어 실행하는 것보다 하나로 묶어서 실행하는 것이 프로그램 상 더 효율적이다. 

⭐️ SET 구 실행 순서

복수의 열을 한 번에 갱신할 때 처리 순서를 알아둘 필요가 있다. 

```sql
UPDATE table0 SET no = no + 1, a = no; # 1번
UPDATE table0 SET a = no, no = no + 1; # 2번
```

위 두 구문은 SET 구의 순서만 다를 뿐 거의 같다. 이를 각각 실행한 결과는 RDBMS 제품 별로 결과가 달라지는데 이는 처리 순서 때문이다. 

> MySQL $\to$ 왼쪽에서 오른쪽으로 순서대로 처리. 

기본 no 값이 1이었다면 1번 실행 결과는 no = 2, a = 2 이다. 2번 실행 결과는 no = 2, a = 1 이다. 

> ORACLE $\to$ 통채로 실행 / 순서 없음. 

기본 no 값이 1이었다면 1번 실행 결과는 no = 2, a = 1 이다. 2번 실행 결과는 no = 2, a = 1 이다. 

여기서 우리가 알아야 할 건 우선 MySQL은 처리 순서가 왼쪽에서 오른쪽으로 대입하며 실행한다는 것이다. 

#### NULL로 갱신

UPDATE 명령으로 셀 값을 NULL로 갱신할 수 있다. 보통 **NULL 초기화**라고 부른다. 

```sql
UPDATE 테이블명 SET a = NULL;
```

셀을 초기화 한다고 생각하면 된다. 당연하지만 셀에 NOT NULL 제약이 있다면 안된다. 

### 물리 삭제와 논리 삭제 

앞서 DELETE 구문을 배워 테이블에서 데이터를 삭제하는 방법을 배웠다. 헌데 사실은 데이터를 삭제하는 방식은 2가지로 나뉜다.  
**물리 삭제**와 **논리 삭제**라는 방식이다. 사실 이것은 어떤 코드, 명령문으로 나뉜다는 것보다는 관념적인 그리고 시스템 설계 측면으로 나뉘는 방법이다. 

#### 물리 삭제 

✅ 정의

물리삭제는 SQL의 DELETE 명령을 사용해 직접 데이터를 삭제하는 사고 방식이다. 즉 실존하는 데이터를 DB에서 아예 없애버린다는 개념이다. 

✅ 장점 및 단점

데이터를 직접 삭제했기에 저장공간이 늘어난다. 또한, 데이터가 완전 삭제됨에 따라 데이터 유출 등의 문제가 사라진다. (개인정보의 경우 완전 삭제가 최고의 보안이기 때문)

하지만, 데이터를 완전히 지운다는 부담, 복구의 어려움, 데이터의 로그 또한 완전히 사라진다는 단점이 있다. 

#### 논리 삭제 

✅ 정의 

논리삭제의 경우, 테이블에 '삭제플래그'와 같은 열을 미리 준비한다. 그리고 해당 데이터를 삭제해야할 때 DELETE를 사용해 삭제하는 것이 아닌 '삭제플레그'열을 카운트하여 마치 삭제된 행이라고 생각하는 것이다. 하여 데이터를 사용할 때 **SELECT * FROM 테이블명 WHERE 삭제플레그 <> 1** 식으로 삭제카운트 외의 데이터만 뽑아서 사용하는 것이다. 

✅ 장점 및 단점

데이터를 삭제하지 않기 때문에 복구가 매우 쉽다. 또한, 데이터의 로그가 보존되어 활용할 수 있다. 

하지만 DB의 저장용량에 일방적으로 부담이 되며 검색 속도가 떨어진다. 


