---
title:  "[MSA] 마이크로서비스 아키텍처 소개" 
excerpt: "마이크로서비스 아키텍처 소개"

categories:
  - Spring

toc: true
toc_sticky: true
 
date: 2023-06-05
last_modified_at: 2023-06-05

---
## 모놀리식 아키텍처와 마이크로서비스 아키텍처의 차이

### 모놀리식 아키텍처
> 하나의 시스템이 서비스 전체 기능을 처리하도록 설계한 것.

![monolithic architecture](/assets/images/file/msa/msa1.jpg)  

모놀리식 아키텍처로 애플리케이션을 설계할 때는 하나의 WAS(Web Application Server)에서 모든 기능을 처리하도록 구성한다.
그리고 데이터를 저장하기 위해 하나의 데이터 저장소를 사용한다. 개발자는 하나의 데이터 저장소에 하나의 애플리케이션을 개발하면 되므로 데이터를 처리하는 일에만 집중하면 된다.
애플리케이션도 하나이므로 코드베이스도 하나면 충분하다. 개발자는 클래스 단위로 기능을 개발하면 되고, 데이터는 객체들 사이에서만 전달된다. 
결국 서비스의 기능들은 클래스들의 유기적인 조합으로 이루어진다.

#### 모놀리식 아키텍처 장점
- 간단한 구조 덕분에 시스템 운영과 개발이 편리하다.
- 네트워크로 인한 지연이나 데이터 유실 걱정이 없다.
- 시스템 장애나 기능에 버그가 있다면 개발자는 하나의 애플리케이션에서 원인을 파악하면 된다.
- 여러 클래스에서 발생하는 로그를 하나의 파일에 기록할 수 있기 때문에 쉽게 원인을 파악할 수 있다.
- 데이터 저장소가 하나이므로 RDB의 트랜잭션 기능을 쉽게 사용할 수 있고 데이터를 여러 테이블에 영속할 때 일관성을 유지할 수 있다.
- 테스트 환경을 쉽게 구성할 수 있으며, 단위 테스트나 통합 테스트를 작성하기 편하다.

#### 모놀리식 아키텍처 단점
- 하나의 애플리케이션 서버에서 여러 기능을 제공하므로 서비스 기능이 많아지면 더욱 복잡해질 수 있다. (스파게티 코드)
- 코드 베이스는 클라이언트 코드와 서버 코드를 포함하기 때문에 클라이언트 코드에 버그를 수정할 때도 서버를 다시 실행해야한다.
- 비기능적 요구 사항 때문에 소스 코드는 증가하고 복잡도도 증가한다.
- 서비스 규모가 커지면 확장에 한계가 있으며 비효율적이다.
- 기능이 많아질수록 개발 속도나 생산성이 낮아지므로 서비스 고도화에 한계가 생긴다.

### 마이크로서비스 아키텍처
> 기능 위주로 나뉜 여러 애플리케이션이 있고, 각각 독립된 데이터 저장소를 사용한다.
> 기능으로 분리된 애플리케이션들은 미리 정의된 인터페이스를 통해 서로 유기적으로 동작한다. 
> 그리고 웹이나 APP 클라이언트에 일관된 형태의 API로 제공된다. 
> 이렇게 기능별로 쪼개진 작은 서비스 혹은 시스템을 마이크로서비스라고한다.  
> 엔터프라이즈 시스템이라는 대규모 시스템을 구축하기 위한 것이며, 기능이 복잡하고 처리량이 많은 시스템에 적합하다.
> 기능이 복잡한 시스템을 편리하게 개발하고 운영하기 위해 소프트웨어 기능을 서비스 단위로 분류하고, 컴포넌트들은 네트워크를 통해 데이터를 통합한다.

![microservice architecture](/assets/images/file/msa/msa2.jpg)  
마이크로서비스 아키텍처의 마이크로서비스들은 각각 다른 마이크로서비스에서 독립적으로 구성되어야 한다. 
마이크로서비스들이 서로 의존한다면 복잡도는 증가한다. 마이크로서비스 하나에 장애가 발생한다면 연쇄적으로 장애가 발생하기 때문이다.
그러므로 각 마이크로서비스는 독립적으로 동작해야하고 다른 마이크로서비스에 의존성을 최소화해야 한다. (느슨한 결합)
데이터 저장소를 공유한다면, 데이터 저장소가 단일 장애 지점이 될 수 있기때문에 마이크로서비스마다 각각 독립된 데이터 저장소가 필요하다.  
각 마이크로서비스 컴포넌트들은 기능을 연동할 때, API를 통해 서로 데이터를 주고받는다. 
하지만 API가 사용하는 네트워크 프로토콜이 성능 저하의 원인이 될 수 있다. 그러므로 통신에 사용되는 네트워크 프로토콜은 가벼워야한다.

#### 마이크로서비스 아키텍처 특징
- 잘 분리된 마이크로서비스로 인한 탈중앙화
- 대규모 시스템을 위한 아키텍처
- 가벼울 네트워크 프로토콜
- 느슨한 결합
- 서비스 지향 아키텍처

## 마이크로서비스의 장/단점
### 마이크로서비스 아키텍처 장점
- 하나의 마이크로서비스는 하나의 비즈니스 기능을 담당하므로 다른 마이크로서비스와 간섭이 최소화된다.
- 독립된 데이터 저장소를 갖기 때문에 대용량 데이터를 마이크로서비스마다 나누어 저장할 수 있다.
- 느슨하게 결합되어 있어 하나의 마이크로서비스에 장애나 버그가 발생하더라도 다른 마이크로서비스는 이상없이 서비스된다.
- 모든 기능이 분리되어 있어 필요한 기능만 먼저 배포할 수 있어 서비스 배포 주기가 빠르다.
- 마이크로서비스 단위로 확장할 수 있어 서비스 전체적으로 확장성이 좋아진다.
- 사용자 반응에 따라 시스템을 고도화하거나 빠르게 시스템에서 제외할 수 있어 민첩하게 대응할 수 있다.

### 마이크로서비스 아키텍처 단점
- 개발하기 어렵다.
- 운영하기 어렵다.
- 설계하기 어렵다.
- 여러 가지 자동화된 시스템이 필요하다. (CI/CD, 모니터링, 로그 통합 검색 등)
- 개발자의 기술력이 좋아야한다.

## 마이크로서비스 아키텍처 설계
> 마이크로서비스를 설계할 때 반드시 목적을 기억하자. 마이크로서비스는 서비스 전체 지능을 빠르게 개발하고 확장하기 위함이다.

1. 서비스 세분화 원칙
   - 비즈니스 기능 : 비즈니스 기능으로 서비스를 분리한다.
   - 성능 : 서비스 크기가 너무 커서 오버헤드가 발생하여 특정 마이크로서비스 성능이 떨어진다면 해당 서비스를 분리한다.
   - 메시지 크기 : API를 설계하는 데 메시지 크기가 크다면 서비스를 분리한다. 단, 비즈니스 기능이나 일관성을 유지하는 트랜잭션에 문제가 없다면 무시해도 좋다.
   - 트랜잭션 : 데이터 정합성을 유지하는 트랜잭션으로 서비스를 분리한다. (데이터를 기준)

2. 도메인 주도 설계(DDD)의 바운디드 컨텍스트
   > 도메인 모델이 존재하는 다른 도메인 모델과 확연히 구분되는 명시적인 경계를 바운디드 컨텍스트라고 한다.
   > 바운디드 컨텍스트는 다른 도메인 모델과 구분되므로 매우 독립적인 영역이다.
   > 그러므로 구분된 바운디드 컨텍스트로 마이크로서비스를 설계하면 다른 마이크로서비스와 중복될 확률이 매우 줄어든다.

3. 단일 책임 원칙
   > 무언가를 변경한다고 했을 때, 함께 변경되는 것들은 서로 연관성이 있음을 의미한다.
   > 연관성이 있으면 하나로 모으면 된다. 그리고 서로 다른이유로 변경되는 것들은 분리한다.

4. 가벼운 통신 프로토콜
   > 마이크로서비스들은 데이터를 통합하기 위해 네트워크를 사용하여 기능을 제공하는데 시스템 리소스를 사용하고
   > 데이터를 직렬화/역직렬화해야 하므로 시스템에 부하를 준다.
   > 이 부하를 최소한으로 줄이는 설계가 필요하다.
   > 그래서 마이크로서비스 사이에는 복잡한 프로토콜대신 HTTP 기반의 REST-API를 많이 사용한다.

5. 외부 공개 인터페이스
   > 마이크로서비스들은 네트워크를 이용하여 서로 통신한다. 이때 외부에 공개하는 인터페이스를 설계할 때는 매우 신중해야한다.
   > 시스템 운영 중에는 즉각적인 수정이나 변경이 힘들어 버전 변경 같은 방법을 이용해서 점진적으로 인터페이스를 변경한다.

6. 마이크로서비스마다 독립된 데이터 저장소
   > 데이터 저장소를 같이 사용한다면 각각의 마이크로서비스 독립성에 위배된다.
   > 그리고 한 마이크로서비스가 과도하게 테이블에 조회나 삭제 쿼리를 실행한다면 데이터베이스의 시스템 부하는 높아질 것이다.
   > 이 데이터베이스를 같이 사용하는 다른 마이크로서비스의 인스턴스들은 처리량이나 처리 속도에 일시적으로 영향을 받는다.
   